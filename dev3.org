#+TITLE: dev3
* spec
rewrite DoublePlot with floats
refactor plots
add subscriptions
* anylogic
- interface:
  - plots:
    - Profit A&B
    - Visitors A&B
    - Revenue A Expenses A
    - Revenue B Expenses B
    - Net Income A&B
  - controls:
    - ad
    - price
    - stores
    - automated stores
- Stocks
  - [X] potentialStock ( potentialFlowSum = -adAFlow -adBFlow +capacityLossAFlow +capacityLossBFlow )
  - [X] regularAStock ( regularAFlowSum =
                                    +adAFlow
                                    +chooseAFlow
                                    -loyalGainAFlow
                                    -capacityLossAFlow )
  - [X] regularBStock ( regularBFlowSum =
                                    +adBFlow
                                    +chooseBFlow
                                    -loyalGainBFlow
                                    -capacityLossBFlow )
  - [X] loyalAStock ( loyalAFlowSum = +loyalGainAFlow )
  - [X] loyalBStock ( loyalBFlowSum = +loyalGainBFlow )
  - [X] profitAStock ( profitAFlowSum = +revenueAFlow -costsAFlow )
                     ( if profitAStock > singleStoreCost then profitAStock - singleStoreCost )
  - [X] profitBStock ( profitBFlowSum = +revenueBFlow -costsBFlow )
                     ( if profitBStock > singleStoreCost then profitBStock - singleStoreCost )
- Flows
  - [X] adAFlow ( adA * potentialStock )
  - [X] adBFlow ( adB * potentialStock )
  - [X] capacityLossAFlow
    ( if totalVisitorsA > targetVisitorsA then
        if chooseAFlow > 0 then
            adAFlow + chooseAFlow
        else
            adAFlow
      else
        0
    )
  - [X] capacityLossBFlow
    ( if totalVisitorsB > targetVisitorsB then
        if chooseBFlow > 0 then
            adBFlow + chooseBFlow
        else
            adBFlow
      else
        0
    )
  - [X] chooseAFlow
    ( ( (relativeRatingA * regularSum) - regularAStock ) * chooseLossFraction )
  - [X] chooseBFlow
    ( ( (relativeRatingB * regularSum) - regularBStock ) * chooseLossFraction )
  - [X] loyalGainAFlow ( regularAStock * loyalGainFraction )
  - [X] loyalGainBFlow ( regularBStock * loyalGainFraction )
  - [X] revenueAFlow ( totalVisitorsA * marginPerPersonA )
  - [X] revenueBFlow ( totalVisitorsB * marginPerPersonB )
  - [X] costsAFlow ( adCostA + rentCostA )
  - [X] costsBFlow ( adCostB + rentCostB)
- variables
  - [X] adA (min 0.002, 0.002, max 0.004) (min 0.2%, 0.2%, max 0.4%)
  - [X] adB (min 0.002, 0.002, max 0.004) (min 0.2%, 0.2%, max 0.4%)
  - [X] priceA (min 2, 6, max 12)
  - [X] priceB (min 2, 6, max 12)
  - [X] primeCostA = 0.3 * priceA
  - [X] primeCostB = 0.3 * priceB
  - [X] marginPerPersonA = priceA - primeCostA
  - [X] marginPerPersonB = priceB - primeCostB
  - [X] storesA ( if profitAStock > singleStoreCost then storesA + 1)
  - [X] storesB ( if profitBStock > SingleStoreCost then storesB + 1)
  - [X] singleStoreVisitors = 1000
  - [X] targetVisitorsA = storesA * singleStoreVisitors
  - [X] targetVisitorsB = storesB * singleStoreVisitors
  - [X] totalVisitorsA = regularAStock + loyalAStock
  - [X] totalVisitorsB = regularBStock + loyalBStock
  - [X] loyalGainFraction = 0.001
  - [X] singleAdCostA = priceA/2
  - [X] singleAdCostB = priceB/2
  - [X] adCostA = adAFlow * singleAdCostA
  - [X] adCostB = adBFlow * singleAdCostB
  - [X] singleRentCost = 3600
  - [X] rentCostA = storesA * singleRentCost
  - [X] rentCostB = storesB * singleRentCost
  - [X] regularSum = regularAStock + regularBStock
  - [X] chooseLossFraction = 0.5
  - [X] relativeRatingA = ratingA / (ratingA + ratingB)
  - [X] relativeRatingB = ratingB / (ratingA + ratingB)
  - [X] ratingA = ratingLookup(relativePriceA)
  - [X] ratingB = ratingLookup(relativePriceB)
  - [X] relativePriceA = priceA / priceB
  - [X] relativePriceB = priceB / priceA
  - [X] singleStoreCost = 100000
- functions
  - [X] ratingLookup( argument:value )
    0.5:10, 0.6:6, 1:5, 1.5:4, 2:1
* lookup
:PROPERTIES:
:header-args: :tangle src/Lookup.elm
:END:
#+BEGIN_SRC elm
module Lookup exposing (..)

lookupList : List (Float, Float)
lookupList = [ (0.5, 10), (0.6, 6), (1, 5), (1.5,4), (2,1) ]

lookupTuples : List (Float, Float)
lookupTuples = [ (0.6, 6), (1, 5) ]

interpolate : Float -> Float -> Float -> Float -> Float -> Float
interpolate x1 y1 x3 y3 x2 =
    if x1 == x3 then
        y1
    else
        y1 + ( ( (x2-x1)*(y3-y1) ) / (x3-x1) )

lookup : List (Float, Float) -> Float -> Float
lookup list x =
    let
        tuples =
            case ((List.maximum (List.filter (\n -> Tuple.first n <= x) list))
                 ,(List.minimum (List.filter (\n -> Tuple.first n >= x) list))
                 ) of

                (Just val, Just val1) ->
                    (val, val1)

                (Just val, Nothing) ->
                    (val, val)

                (Nothing, Just val) ->
                    (val, val)

                _ ->
                    ((0,0), (0,0))

        xone =
            Tuple.first (Tuple.first tuples)

        yone =
            Tuple.second (Tuple.first tuples)

        xtri =
            Tuple.first (Tuple.second tuples)

        ytri =
            Tuple.second (Tuple.second tuples)
    in
        interpolate xone yone xtri ytri x
#+END_SRC
* plots
:PROPERTIES:
:header-args: :tangle src/ChartAB.elm
:END:
** double area
#+BEGIN_SRC elm

module ChartAB exposing (view)

import Axis
import Color exposing (Color)
import Path exposing (Path)
import Scale exposing (ContinuousScale, OrdinalScale)
import Scale.Color
import Shape
import Statistics
import Time
import TypedSvg exposing (g, svg, text_)
import TypedSvg.Attributes exposing (class, dy, fill, fontFamily, stroke, textAnchor, transform, viewBox)
import TypedSvg.Attributes.InPx exposing (fontSize, height, strokeWidth, x, y)
import TypedSvg.Core exposing (Svg, text)
import TypedSvg.Types exposing (AnchorAlignment(..), Fill(..), Transform(..), em)


-- MAIN

-- MODEL

type alias DoublePlot =
    { time : Float
    , firstLine : Float
    , secondLine : Float
    }

-- UPDATE


-- SUBSCRIPTIONS


-- VIEW


w : Float
w =
    900


h : Float
h =
    450


padding : Float
padding =
    60


series =
    [ { label = "A"
      , accessor = .firstLine
      }
    , { label = "B"
      , accessor = .secondLine
      }
    ]


accessors : List (DoublePlot -> Float)
accessors =
    List.map .accessor series


values : DoublePlot -> List Float
values i =
    List.map (\a -> a i) accessors


colorScale : OrdinalScale String Color
colorScale =
    List.map .label series
        |> Scale.ordinal [(Color.rgba 1 0 0 0.3)
                         ,(Color.rgba 0 1 0 0.3)
                         ,(Color.rgba 0 0 1 0.3)
                         ]


color : String -> Color
color =
    Scale.convert colorScale >> Maybe.withDefault Color.black



view : List DoublePlot -> Svg msg
view model =
    let
        last =
            List.reverse model
                |> List.head
                |> Maybe.withDefault (CrimeRate 0 0 0 )

        first =
            List.head model
                |> Maybe.withDefault (CrimeRate 0 0 0 )

        xScale : ContinuousScale Float
        xScale =
            model
                |> List.map (.time)
                |> Statistics.extent
                |> Maybe.withDefault ( 1900, 1901 )
                |> Scale.linear ( 0, w - 2 * padding )

        yScale : ContinuousScale Float
        yScale =
            model
                |> List.map (values >> List.maximum >> Maybe.withDefault 0)
                |> List.maximum
                |> Maybe.withDefault 0
                |> (\b -> ( 0, b ))
                |> Scale.linear ( h - 2 * padding, 0 )
                |> Scale.nice 4

        lineGenerator : ( Float, Float ) -> Maybe ( Float, Float )
        lineGenerator ( x, y ) =
            Just ( Scale.convert xScale (x), Scale.convert yScale (y) )

        areaGenerator : ( Float, Float ) -> Maybe ( ( Float, Float ), ( Float, Float ) )
        areaGenerator ( x, y ) =
            Just
                ( ( Scale.convert xScale (x), Tuple.first (Scale.rangeExtent yScale) )
                , ( Scale.convert xScale (x), Scale.convert yScale (y) )
                )

        line : (DoublePlot -> Float) -> Path
        line accessor =
            List.map (\i -> ( .time i, accessor i )) model
                |> List.map lineGenerator
                |> Shape.line Shape.monotoneInXCurve

        area : (DoublePlot -> Float) -> Path
        area accessor =
            List.map (\i -> ( .time i, accessor i )) model
                |> List.map areaGenerator
                |> Shape.area Shape.monotoneInXCurve
    in
    svg [ viewBox 0 0 w h ]
        [ g [ class [ "tata" ], fontSize 40, fontFamily [ "sans-serif" ], transform [ Translate (padding - 1) (h - padding) ] ]
            [ Axis.bottom [ Axis.tickCount 3 ] xScale ]
        , g [ class [ "dada" ], fontSize 40, transform [ Translate (padding - 1) padding ] ]
            [ Axis.left [ Axis.tickCount 3 ] yScale
            , text_ [ fontFamily [ "sans-serif" ], fontSize 15, x 5, y 5 ] [ text "Occurences" ]
            ]
        , g [ fontSize 20,  transform [ Translate padding padding ], class [ "series" ] ]
            (List.map
                (\{ accessor, label } ->
                    Path.element (line accessor)
                        [ stroke (color label)
                        , strokeWidth 3
                        , fill FillNone
                        ]
                )
                series
            )
        , g [ fontSize 20, transform [ Translate padding padding ], class [ "series" ] ]
            (List.map
                (\{ accessor, label } ->
                    Path.element (area accessor) [ strokeWidth 3, fill <| Fill <| (color label) ]
                )
                series
            )
        , g [ fontFamily [ "sans-serif" ], fontSize 20 ]
            (List.map
                (\{ accessor, label } ->
                    g
                        [ transform
                            [ Translate (w - padding + 10) (padding + Scale.convert yScale (accessor last))
                            ]
                        ]
                        [ text_ [ fill (Fill (color label)) ] [ text label ] ]
                )
                series
            )
        ]

#+END_SRC
* code
:PROPERTIES:
:header-args: :tangle src/Dev3.elm
:END:
** imports
#+BEGIN_SRC elm
module Dev3 exposing (..)

import Browser

import Element exposing (..)
import Element.Background as Background
import Element.Border as Border
import Element.Input as Input
import Html exposing (Html, div)
import Html.Attributes exposing (style, class)
import Task
import Time
import Css exposing (fontSize)
import Css.Global exposing (class, global)
import Html.Styled exposing (toUnstyled)

import ChartAB exposing (view)
#+END_SRC
** main
#+BEGIN_SRC elm
-- MAIN
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }
#+END_SRC
** model
#+BEGIN_SRC elm
-- MODEL

type alias Model =
    { stocks = Stocks
    , plots = Plots
    , parameters = Parameters
    , times = Times
    , states = States
    }

type alias Stocks =
    { potentialStock : Float
    , regularAStock : Float
    , regularBStock : Float
    , loyalAStock : Float
    , loyalBStock : Float
    , profitAStock : Float
    , profitBStock
    }

type alias Plots =
    { visitorsPlot : List DoublePlot
    , balanceAPlot : List DoublePlot
    , balanceBPlot : List DoublePlot
    , incomePlot : List DoublePlot
    , profitPlot : List DoublePlot
    }

type alias DoublePlot =
    { time : Float
    , firstLine : Float
    , secondLine : Float
    }

type alias Parameters =
    { priceA : Float
    , priceB : Float
    , adA : Float
    , adB : Float
    , storesA : Float
    , storesB : Float
    }

type alias Times =
    { plotTime : Float
    , stockTime : Float
    }

type alias States =
    { paused : Bool
    , autoA : Bool
    , autoB : Bool
    }

init : () -> ( Model, Cmd Msg )
       ( { stocks = { potentialStock = 50000
                    , regularAStock = 0
                    , regularBStock = 0
                    , loyalAStock = 0
                    , loyalBStock = 0
                    , profitAStock = 0
                    , profitBStock = 0
                    }
         , plots = { visitorsPlot = []
                   , balanceAPlot = []
                   , balanceBPlot = []
                   , netIncomePlot = []
                   , profitPlot = []
                   }
         , parameters = { priceA = 6
                        , priceB = 6
                        , adA = 0.002
                        , adB = 0.002
                        , storesA = 1
                        , storesB = 1
                        }
         , times = { plotTime = 0
                   , stockTime = 0
                   }
         , states = { paused = True
                    , autoA = True
                    , autoB = True
                    }
         }
       , Cmd.none
       )
#+END_SRC
** update
#+BEGIN_SRC elm
-- UPDATE

type Msg
    = PlotTick Time.Posix
    | StockTick Time.Posix
    | AdjustAdA Float
    | AdjustAdB Float
    | AdjustPriceA Float
    | AdjustPriceB Float
    | OpenStoreA
    | OpenStoreB
    | AutoStoreA Bool
    | AutoStoreB Bool
    | PauseModel Bool

update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        PlotTick newTime ->
            ( { model | times = { plotTime = model.times.plotTime + 1, stockTime = model.times.stockTime },
                        plots = { visitorsPlot = updateVisitorsPlot model
                                , balanceAPlot = updateBalanceAPlot model
                                , balanceBPlot = updateBalanceBPlot model
                                , incomePlot = updateIncomePlot model
                                , profitPlot = updateProfitPlot model
                                }
              }
            , Cmd.none
            )

        StockTick newTime ->
            ( { model | times = { plotTime = model.times.plotTime, stockTime = model.times.stockTime + 1 }
                        stocks = { potentialStock = integral model model.times.stockTime model.stocks.potentialStock potentialFlowSum 0.001
                                 , regularAStock = integral model model.times.stockTime model.stocks.regularAStock regularAFlowSum 0.001
                                 , regularBStock = integral model model.times.stockTime model.stocks.regularBStock regularBFlowSum 0.001
                                 , loyalAStock = integral model model.times.stockTime model.stocks.loyalAStock loyalAFlowSum 0.001
                                 , loyalBStock = integral model model.times.stockTime model.stocks.loyalBStock loyalBFlowSum 0.001
                                 , profitAStock = integral model model.times.stockTime model.stocks.profitAStock profitAFlowSum 0.001
                                 , profitBStock = integral model model.times.stockTime model.stocks.profitBStock profitBFlowSum 0.001
                                 }
              }
            , Cmd.none
            )

        AdjustAdA newAd ->
            let
                oldParameters = model.parameters
                newParameters = { oldParameters | adA = newAd }
            in
                ( { model | parameters = newParameters }
                , Cmd.none
                )

        AdjustAdB newAd ->
            let
                oldParameters = model.parameters
                newParameters = { oldParameters | adB = newAd }
            in
                ( { model | parameters = newParameters }
                , Cmd.none
                )

        AdjustPriceA newPrice ->
            let
                oldParameters = model.parameters
                newParameters = { oldParameters | priceA = newPrice }
            in
                ( { model | parameters = newParameters }
                , Cmd.none
                )

        AdjustPriceB newPrice ->
            let
                oldParameters = model.parameters
                newParameters = { oldParameters | priceB = newPrice }
            in
                ( { model | parameters = newParameters }
                , Cmd.none
                )

        OpenStoreA ->
            let
                oldParameters = model.parameters
                newParameters = { oldParameters | storesA = model.parameters.storesA + 1 }
                oldStocks = model.stocks
                newStocks = { oldStocks | profitAStock = model.stocks.profitAStock - singleStoreCost }
            in
                if model.stocks.profitAStock > singleStoreCost then
                    ( { model | parameters = newParameters, stock = newStocks }
                    , Cmd.none
                    )
                else
                    ( model
                    , Cmd.none
                    )

        OpenStoreB ->
            let
                oldParameters = model.parameters
                newParameters = { oldParameters | storesB = model.parameters.storesB + 1 }
                oldStocks = model.stocks
                newStocks = { oldStocks | profitBStock = model.stocks.profitBStock - singleStoreCost }
            in
                if model.stocks.profitBStock > singleStoreCost then
                    ( { model | parameters = newParameters, stock = newStocks }
                    , Cmd.none
                    )
                else
                    ( model
                    , Cmd.none
                    )

        AutoStoreA state ->
            let
                oldStates = model.states
                newStates = { oldStates | autoA = state }
            in
                ( { model | states = newStates }
                , Cmd.none
                )

        AutoStoreB state ->
            let
                oldStates = model.states
                newStates = { oldStates | autoB = state }
            in
                ( { model | states = newStates }
                , Cmd.none
                )

        PauseModel state ->
            let
                oldStates = model.states
                newStates = { oldStates | paused = state }
            in
                ( { model | states = newStates }
                , Cmd.none
                )
#+END_SRC
** functions
#+BEGIN_SRC elm
-- FUNCTIONS
--
--- PLOTS

updateVisitorsPlot : Model -> List DoublePlot
updateVisitorsPlot model =
    List.append model.plots.visitorsPlot [{ time = model.times.plotTime
                                          , firstLine = model.stocks.regularAStock + model.stocks.loyalAStock
                                          , secondLine = model.stocks.regularBStock + model.stocks.loyalBStock
                                          }]

updateBalanceAPlot : Model -> List DoublePlot
updateBalanceAPlot model =
    List.append model.plots.balanceAPlot [{ time = model.times.plotTime
                                          , firstLine = revenueAFlow model 0 0 -- model.times.stockTime model.stocks.profitAStock
                                          , secondLine = costsAFlow model 0 0 -- model.times.stockTime model.stocks.profitAStock
                                          }]

updateBalanceBPlot : Model -> List DoublePlot
updateBalanceBPlot model =
    List.append model.plots.balanceBPlot [{ time = model.times.plotTime
                                          , firstLine = revenueBFlow model 0 0 -- model.times.stockTime model.stocks.profitBStock
                                          , secondLine = costsBFlow model 0 0 -- model.times.stockTime model.stocks.profitBStock
                                          }]

updateIncomePlot : Model -> List DoublePlot
updateIncomePlot model =
    List.append model.plots.incomePlot [{ time = model.times.plotTime
                                        , firstLine = revenueAFlow model 0 0 - costsAFlow model 0 0
                                        , secondLine = revenueBFlow model 0 0 - costsBFlow model 0 0
                                        }]

updateProfitPlot : Model -> List DoublePlot
updateProfitPlot model =
    List.append model.plots.profitPlot [{ time = model.times.plotTime
                                        , firstLine = model.stocks.profitAStock
                                        , secondLine = model.stocks.profitBStock
                                        }]

--- STOCKS


potentialFlowSum : Model -> Float
potentialFlowSum model =
    (-adAFlow model) + (-adBFlow model) + (capacityLossAFlow model) + (capacityLossBFlow model)

regularAFlowSum : Model -> Float
regularAFlowSum model =
    (adAFlow model) + (chooseAFlow model) + (-loyalGainAFlow model) + (-capacityLossAFlow model)

regularBFlowSum : Model -> Float
regularBFlowSum model =
    (adBFlow model) + (chooseBFlow model) + (-loyalGainBFlow model) + (-capacityLossBFlow model)

loyalAFlowSum : Model -> Float
loyalAFlowSum model =
    (loyalGainAFlow model)

loyalBFlowSum : Model -> Float
loyalBFlowSum model =
    (loyalGainBFlow model)

profitAFlowSum : Model -> Float
profitAFlowSum model =
    (revenueAFlow model) + (-costsAFlow model)

profitBFlowSum : Model -> Float
profitBFlowSum model =
    (revenueBFlow model) + (-costsBFlow model)


--- FLOWS


adAFlow : Model -> Float
adAFlow model =
    adA * model.stocks.potentialStock

adBFlow : Model -> Float
adBFlow model =
    adB * model.stocks.potentialStock

capacityLossAFlow : Model -> Float
capacityLossAFlow model =
    if (model.stocks.regularAStock + model.stocks.loyalAStock) > targetVisitorsA then
        if chooseAFlow model > 0 then
            adAFlow model + chooseAFlow model
        else
            adAFlow model
    else
        0

capacityLossBFlow : Model -> Float
capacityLossBFlow model =
    if (model.stocks.regularBStock + model.stocks.loyalBStock) > targetVisitorsB then
        if chooseBFlow model > 0 then
            adBFlow model + chooseBFlow model
        else
            adBFlow model
    else
        0

chooseAFlow : Model -> Float
chooseAFlow model =
    let
        relativeRatingA = ratingA model / (ratingA model + ratingB model)
        regularSum = model.stocks.regularAStock + model.stocks.regularBStock
    in
        ( ( (relativeRatingA * regularSum) - model.stocks.regularAStock ) * chooseLossFraction )

chooseBFlow : Model -> Float
chooseBFlow model =
    let
        relativeRatingB = ratingB model / (ratingA model + ratingB model)
        regularSum = model.stocks.regularAStock + model.stocks.regularBStock
    in
        ( ( (relativeRatingB * regularSum) - model.stocks.regularBStock ) * chooseLossFraction )

loyalGainAFlow : Model -> Float
loyalGainAFlow model =
    model.stocks.regularAStock * loyalGainFraction

loyalGainBFlow : Model -> Float
loyalGainBFlow model =
    model.stocks.regularBStock * loyalGainFraction

revenueAFlow : Model -> Float
revenueAFlow model =
    (model.stocks.regularAStock + model.stocks.loyalAStock) * marginPerPersonA model

revenueBFlow : Model -> Float
revenueBFlow model =
    (model.stocks.regularBStock + model.stocks.loyalBStock) * marginPerPersonB model

costsAFlow : Model -> Float
costsAFlow model =
    adCostA model + rentCostA model

costsBFlow : Model -> Float
costsBFlow model =
    adCostB model + rentCostB model


--- VARIABLES


marginPerPersonA : Model -> Float
marginPerPersonA model =
    let
        primeCostA = model.parameters.priceA * primeCostFraction
    in
        model.parameters.priceA - primeCostA

marginPerPersonB : Model -> Float
marginPerPersonB model =
    let
        primeCostB = model.parameters.priceB * primeCostFraction
    in
        model.parameters.priceB - primeCostB

targetVisitorsA : Model -> Float
targetVisitorsA model =
    model.parameters.storesA * singleStoreVisitors

targetVisitorsB : Model -> Float
targetVisitorsB model =
    model.parameters.storesB * singleStoreVisitors

adCostA : Model -> Float
adCostA model =
    let
        singleAdCostA = model.parameters.priceA/2
    in
        adAFlow model * singleAdCostA

adCostB : Model -> Float
adCostB model =
    let
        singleAdCostB = model.parameters.priceB/2
    in
        adBFlow model * singleAdCostB

rentCostA : Model -> Float
rentCostA model =
    model.parameters.storesA * singleRentCost

rentCostB : Model -> Float
rentCostB model =
    model.parameters.storesB * singleRentCost

ratingA : Model -> Float
ratingA model =
    let
        relativePriceA = model.parameters.priceA / model.parameters.priceB
    in
        lookup ratingLookup relativePriceA

ratingB : Model -> Float
ratingB model =
    let
        relativePriceB = model.parameters.priceB / model.parameters.priceA
    in
        lookup ratingLookup relativePriceB


--- CONSTANTS


primeCostFraction : Float
primeCostFraction = 0.3

singleStoreVisitors : Float
singleStoreVisitors = 1000

loyalGainFraction : Float
loyalGainFraction = 0.001

singleRentCost : Float
singleRentCost = 3600

chooseLossFraction : Float
chooseLossFraction = 0.5

singleStoreCost : Float
singleStoreCost = 100000


--- LOOKUP


interpolate : Float -> Float -> Float -> Float -> Float -> Float
interpolate x1 y1 x3 y3 x2 =
    if x1 == x3 then
        y1
    else
        y1 + ( ( (x2-x1)*(y3-y1) ) / (x3-x1) )

lookup : List (Float, Float) -> Float -> Float
lookup list x =
    let
        tuples =
            case ((List.maximum (List.filter (\n -> Tuple.first n <= x) list))
                 ,(List.minimum (List.filter (\n -> Tuple.first n >= x) list))
                 ) of

                (Just val, Just val1) ->
                    (val, val1)

                (Just val, Nothing) ->
                    (val, val)

                (Nothing, Just val) ->
                    (val, val)

                _ ->
                    ((0,0), (0,0))

        xone =
            Tuple.first (Tuple.first tuples)

        yone =
            Tuple.second (Tuple.first tuples)

        xtri =
            Tuple.first (Tuple.second tuples)

        ytri =
            Tuple.second (Tuple.second tuples)
    in
        interpolate xone yone xtri ytri x
#+END_SRC
** subscriptions
#+BEGIN_SRC elm

subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.batch
        [ Time.every 1000 PlotTick
        , Time.every 1 StockTick
        ]

#+END_SRC
** view
#+BEGIN_SRC elm
-- VIEW


view : Model -> Html Msg
view model =
    layout []
        (column []
             [ row []
                   [ html <| ChartAB.view model.plots.visitorsPlot
                   , html <| ChartAB.view model.plots.balanceAPlot
                   , html <| ChartAB.view model.plots.incomePlot
                   , html <| ChartAB.view model.plots.balanceBPlot
                   , html <| ChartAB.view model.plots.profitPlot
                   ]
             , row []
                   [ controlsA model
                   , controlsB model
                   ]
             ]
        )

controlsA : Model -> Html Msg
controlsA model =
    row []
        [ column []
              [ slider AdjustAdA model.parameters.adA 0.002 0.004
              , slider AdjustPriceA model.parameters.priceA 2 12
              ]
        , column []
              [ Input.checkbox []
                    { onChange = AutoStoreA
                    , icon = Input.defaultCheckbox
                    , checked = model.states.autoA
                    , label = Input.labelRight [] (text "auto stores")
                    }
              , text (String.fromFloat model.parameters.storesA)
              , Input.button [] { onPress = Just OpenStoreA, label = text "Open Store A" }
              ]
        ]

controlsB : Model -> Html Msg
controlsB model =
    row []
        [ column []
              [ slider AdjustAdB model.parameters.adB 0.002 0.004
              , slider AdjustPriceB model.parameters.priceB 2 12
              ]
        , column []
              [ Input.checkbox []
                    { onChange = AutoStoreB
                    , icon = Input.defaultCheckbox
                    , checked = model.states.autoB
                    , label = Input.labelRight [] (text "auto stores")
                    }
              , text (String.fromFloat model.parameters.storesB)
              , Input.button [] { onPress = Just OpenStoreB, label = text "Open Store B" }
              ]
        ]

slider : (Float -> Msg) -> Float -> Float -> Float -> Element Msg
slider msg v vmin vmax =
    Input.slider
        [ Element.height (Element.px 30)

        -- Here is where we're creating/styling the "track"
        , Element.behindContent
            (Element.el
                [ Element.width Element.fill
                , Element.height (Element.px 2)
                , Element.centerY
                , Background.color (rgb 0 0.5 0)
                , Border.rounded 2
                ]
                Element.none
            )
        ]
        { onChange = msg
        , label = Input.labelAbove [] (text (String.fromFloat v))
        , min = vmin
        , max = vmax
        , step = Nothing
        , value = v
        , thumb = Input.defaultThumb
        }
#+END_SRC
