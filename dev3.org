#+TITLE: dev3
* anylogic
- interface:
  - plots:
    - Profit A&B
    - Visitors A&B
    - Revenue A Expenses A
    - Revenue B Expenses B
    - Net Income A&B
  - controls:
    - ad
    - price
    - stores
    - automated stores
- Stocks
  - [X] potentialStock ( potentialFlowSum = -adAFlow -adBFlow +capacityLossAFlow +capacityLossBFlow )
  - [X] regularAStock ( regularAFlowSum =
                                    +adAFlow
                                    +chooseAFlow
                                    -loyalGainAFlow
                                    -capacityLossAFlow )
  - [X] regularBStock ( regularBFlowSum =
                                    +adBFlow
                                    +chooseBFlow
                                    -loyalGainBFlow
                                    -capacityLossBFlow )
  - [X] loyalAStock ( loyalAFlowSum = +loyalGainAFlow )
  - [X] loyalBStock ( loyalBFlowSum = +loyalGainBFlow )
  - [X] profitAStock ( profitAFlowSum = +revenueAFlow -costsAFlow )
                     ( if profitAStock > singleStoreCost then profitAStock - singleStoreCost )
  - [X] profitBStock ( profitBFlowSum = +revenueBFlow -costsBFlow )
                     ( if profitBStock > singleStoreCost then profitBStock - singleStoreCost )
- Flows
  - [X] adAFlow ( adA * potentialStock )
  - [X] adBFlow ( adB * potentialStock )
  - [X] capacityLossAFlow
    ( if totalVisitorsA > targetVisitorsA then
        if chooseAFlow > 0 then
            adAFlow + chooseAFlow
        else
            adAFlow
      else
        0
    )
  - [X] capacityLossBFlow
    ( if totalVisitorsB > targetVisitorsB then
        if chooseBFlow > 0 then
            adBFlow + chooseBFlow
        else
            adBFlow
      else
        0
    )
  - [X] chooseAFlow
    ( ( (relativeRatingA * regularSum) - regularAStock ) * chooseLossFraction )
  - [X] chooseBFlow
    ( ( (relativeRatingB * regularSum) - regularBStock ) * chooseLossFraction )
  - [X] loyalGainAFlow ( regularAStock * loyalGainFraction )
  - [X] loyalGainBFlow ( regularBStock * loyalGainFraction )
  - [X] revenueAFlow ( totalVisitorsA * marginPerPersonA )
  - [X] revenueBFlow ( totalVisitorsB * marginPerPersonB )
  - [X] costsAFlow ( adCostA + rentCostA )
  - [X] costsBFlow ( adCostB + rentCostB)
- variables
  - [X] adA (min 0.002, 0.002, max 0.004) (min 0.2%, 0.2%, max 0.4%)
  - [X] adB (min 0.002, 0.002, max 0.004) (min 0.2%, 0.2%, max 0.4%)
  - [X] priceA (min 2, 6, max 12)
  - [X] priceB (min 2, 6, max 12)
  - [X] primeCostA = 0.3 * priceA
  - [X] primeCostB = 0.3 * priceB
  - [X] marginPerPersonA = priceA - primeCostA
  - [X] marginPerPersonB = priceB - primeCostB
  - [X] storesA ( if profitAStock > singleStoreCost then storesA + 1)
  - [X] storesB ( if profitBStock > SingleStoreCost then storesB + 1)
  - [X] singleStoreVisitors = 1000
  - [X] targetVisitorsA = storesA * singleStoreVisitors
  - [X] targetVisitorsB = storesB * singleStoreVisitors
  - [X] totalVisitorsA = regularAStock + loyalAStock
  - [X] totalVisitorsB = regularBStock + loyalBStock
  - [X] loyalGainFraction = 0.001
  - [X] singleAdCostA = priceA/2
  - [X] singleAdCostB = priceB/2
  - [X] adCostA = adAFlow * singleAdCostA
  - [X] adCostB = adBFlow * singleAdCostB
  - [X] singleRentCost = 3600
  - [X] rentCostA = storesA * singleRentCost
  - [X] rentCostB = storesB * singleRentCost
  - [X] regularSum = regularAStock + regularBStock
  - [X] chooseLossFraction = 0.5
  - [X] relativeRatingA = ratingA / (ratingA + ratingB)
  - [X] relativeRatingB = ratingB / (ratingA + ratingB)
  - [X] ratingA = ratingLookup(relativePriceA)
  - [X] ratingB = ratingLookup(relativePriceB)
  - [X] relativePriceA = priceA / priceB
  - [X] relativePriceB = priceB / priceA
  - [X] singleStoreCost = 100000
- functions
  - [X] ratingLookup( argument:value )
    0.5:10, 0.6:6, 1:5, 1.5:4, 2:1
* spec
rewrite DoublePlot with floats
refactor plots
* lookup
:PROPERTIES:
:header-args: :tangle src/Lookup.elm
:END:
#+BEGIN_SRC elm
module Lookup exposing (..)

lookupList : List (Float, Float)
lookupList = [ (0.5, 10), (0.6, 6), (1, 5), (1.5,4), (2,1) ]

lookupTuples : List (Float, Float)
lookupTuples = [ (0.6, 6), (1, 5) ]

interpolate : Float -> Float -> Float -> Float -> Float -> Float
interpolate x1 y1 x3 y3 x2 =
    if x1 == x3 then
        y1
    else
        y1 + ( ( (x2-x1)*(y3-y1) ) / (x3-x1) )

lookup : List (Float, Float) -> Float -> Float
lookup list x =
    let
        tuples =
            case ((List.maximum (List.filter (\n -> Tuple.first n <= x) list))
                 ,(List.minimum (List.filter (\n -> Tuple.first n >= x) list))
                 ) of

                (Just val, Just val1) ->
                    (val, val1)

                (Just val, Nothing) ->
                    (val, val)

                (Nothing, Just val) ->
                    (val, val)

                _ ->
                    ((0,0), (0,0))

        xone =
            Tuple.first (Tuple.first tuples)

        yone =
            Tuple.second (Tuple.first tuples)

        xtri =
            Tuple.first (Tuple.second tuples)

        ytri =
            Tuple.second (Tuple.second tuples)
    in
        interpolate xone yone xtri ytri x
#+END_SRC
* plots
** single line
** single area
** double line
** double area
* main
:PROPERTIES:
:header-args: :tangle src/Dev3.elm
:END:
** imports
#+BEGIN_SRC elm

module Dev3 exposing (..)


#+END_SRC
** main
#+BEGIN_SRC elm
-- MAIN
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }
#+END_SRC
** model
#+BEGIN_SRC elm
-- MODEL

type alias Model =
    { stocks = Stocks
    , plots = Plots
    , parameters = Parameters
    , times = Times
    , states = States
    }

type alias Stocks =
    { potentialStock : Float
    , regularAStock : Float
    , regularBStock : Float
    , loyalAStock : Float
    , loyalBStock : Float
    , profitAStock : Float
    , profitBStock
    }

type alias Plots =
    { visitorsPlot : List DoublePlot
    , balanceAPlot : List DoublePlot
    , balanceBPlot : List DoublePlot
    , netIncomePlot : List DoublePlot
    , profitPlot : List DoublePlot
    }

type alias DoublePlot =
    { time : Int
    , firstLine : Int
    , secondLine : Int
    }

type alias Parameters =
    { priceA : Float
    , priceB : Float
    , adA : Float
    , adB : Float
    , storesA : Float
    , storesB : Float
    }

type alias Times =
    { plotTime : Float
    , stockTime : Float
    }

type alias States =
    { paused : Bool
    , autoA : Bool
    , autoB : Bool
    }

init : () -> ( Model, Cmd Msg )
       ( { stocks = { potentialStock = 50000
                    , regularAStock = 0
                    , regularBStock = 0
                    , loyalAStock = 0
                    , loyalBStock = 0
                    , profitAStock = 0
                    , profitBStock = 0
                    }
         , plots = { visitorsPlot = []
                   , balanceAPlot = []
                   , balanceBPlot = []
                   , netIncomePlot = []
                   , profitPlot = []
                   }
         , parameters = { priceA = 6
                        , priceB = 6
                        , adA = 0.002
                        , adB = 0.002
                        , storesA = 1
                        , storesB = 1
                        }
         , times = { plotTime = 0
                   , stockTime = 0
                   }
         , states = { paused = True
                    , autoA = True
                    , autoB = True
                    }
         }
       , Cmd.none
       )
#+END_SRC
** update
#+BEGIN_SRC elm
-- UPDATE
#+END_SRC
** view
#+BEGIN_SRC elm
-- VIEW
#+END_SRC
