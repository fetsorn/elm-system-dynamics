#+TITLE: dev3
* anylogic
- interface:
  - plots:
    - Profit A&B
    - Visitors A&B
    - Revenue A Expenses A
    - Revenue B Expenses B
    - Net Income A&B
  - controls:
    - ad
    - price
    - stores
    - automated stores
- Stocks
  - [X] potentialStock ( potentialFlowSum = -adAFlow -adBFlow +capacityLossAFlow +capacityLossBFlow )
  - [X] regularAStock ( regularAFlowSum =
                                    +adAFlow
                                    +chooseAFlow
                                    -loyalGainAFlow
                                    -capacityLossAFlow )
  - [X] regularBStock ( regularBFlowSum =
                                    +adBFlow
                                    +chooseBFlow
                                    -loyalGainBFlow
                                    -capacityLossBFlow )
  - [X] loyalAStock ( loyalAFlowSum = +loyalGainAFlow )
  - [X] loyalBStock ( loyalBFlowSum = +loyalGainBFlow )
  - [X] profitAStock ( profitAFlowSum = +revenueAFlow -costsAFlow )
  - [X] profitBStock ( profitBFlowSum = +revenueBFlow -costsBFlow )
- Flows
  - [X] adAFlow ( adA * potentialStock )
  - [X] adBFlow ( adB * potentialStock )
  - [X] capacityLossAFlow
    ( if totalVisitorsA > targetVisitorsA then
        if chooseAFlow > 0 then
            adAFlow + chooseAFlow
        else
            adAFlow
      else
        0
    )
  - [X] capacityLossBFlow
    ( if totalVisitorsB > targetVisitorsB then
        if chooseBFlow > 0 then
            adBFlow + chooseBFlow
        else
            adBFlow
      else
        0
    )
  - [ ] chooseAFlow
    ( ( (relativeRatingA * regularSum) - regularAStock ) * chooseLossFraction )
  - [ ] chooseBFlow
    ( ( (relativeRatingB * regularSum) - regularBStock ) * chooseLossFraction )
  - [X] loyalGainAFlow ( regularAStock * loyalGainFraction )
  - [X] loyalGainBFlow ( regularBStock * loyalGainFraction )
  - [X] revenueAFlow ( totalVisitorsA * marginPerPersonA )
  - [X] revenueBFlow ( totalVisitorsB * marginPerPersonB )
  - [X] costsAFlow ( adCostA + rentCostA )
  - [X] costsBFlow ( adCostB + rentCostB)
- variables
  - [ ] priceA
  - [ ] priceB
  - [ ] primeCostA
  - [ ] primeCostB
  - [X] marginPerPersonA = priceA - primeCostA
  - [X] marginPerPersonB = priceB - primeCostB
  - [ ] storesA
  - [ ] storesB
  - [ ] singleStoreVisitors
  - [X] targetVisitorsA = storesA * singleStoreVisitors
  - [X] targetVisitorsB = storesB * singleStoreVisitors
  - [X] totalVisitorsA = regularAStock + loyalAStock
  - [X] totalVisitorsB = regularBStock + loyalBStock
  - [ ] loyalGainFraction
  - [ ] singleAdCostA
  - [ ] singleAdCostB
  - [X] adCostA = adAFlow * singleAdCostA
  - [X] adCostB = adBFlow * singleAdCostB
  - [ ] singleRentCost
  - [X] rentCostA = storesA * singleRentCost
  - [X] rentCostB = storesB * singleRentCost
  - [X] regularSum = regularAStock + regularBStock
  - [ ] chooseLossFraction
  - [X] relativeRatingA = ratingA / (ratingA + ratingB)
  - [X] relativeRatingB = ratingB / (ratingA + ratingB)
  - [X] ratingA = ratingLookup(relativePriceA)
  - [X] ratingB = ratingLookup(relativePriceB)
  - [X] relativePriceA = priceA / priceB
  - [X] relativePriceB = priceB / priceA
- lookup
  - ratingLookup( argument:value )
    0.5:10, 0.6:6, 1:5, 1.5:4, 2:1

* spec
:PROPERTIES:
:header-args: :tangle src/Lookup.elm
:END:
separate type alias for parameters
decide on lookup implementation
  - list = [ (0.5, 10), (0.6, 6), (1, 5), (1.5,4), (2,1) ]
  - lookup list x =
    List.filter (\n -> Tuple.first n > x && Tuple.first n < x+1 ) list
  - interpolate x1 y1 x3 y3 x2 =
    y1 + ( ( (x2-x1)*(y3-y1) ) / (x3 - x1) )
decide on store automation
#+BEGIN_SRC elm
module Lookup exposing (..)

lookupList : List (Float, Float)
lookupList = [ (0.5, 10), (0.6, 6), (1, 5), (1.5,4), (2,1) ]

lookupTuples : List (Float, Float)
lookupTuples = [ (0.6, 6), (1, 5) ]

interpolate : Float -> Float -> Float -> Float -> Float -> Float
interpolate x1 y1 x3 y3 x2 =
    if x1 == x3 then
        y1
    else
        y1 + ( ( (x2-x1)*(y3-y1) ) / (x3-x1) )

eatTuples : ( (Float, Float), (Float, Float) ) -> Float -> Float
eatTuples tuples x =
    let
        xone =
            Tuple.first (Tuple.first tuples)

        yone =
            Tuple.second (Tuple.first tuples)

        xtri =
            Tuple.first (Tuple.second tuples)

        ytri =
            Tuple.second (Tuple.second tuples)
    in
    interpolate xone yone xtri ytri x

pickLowTuple : List (Float, Float) -> Float -> (Float, Float)
pickLowTuple list x =
    case (List.maximum (List.filter (\n -> Tuple.first n <= x) list) ) of
        Just val ->
            val

        Nothing ->
            (0,0)
--    (0,0)

pickHighTuple : List (Float, Float) -> Float -> (Float, Float)
pickHighTuple list x =
    case (List.minimum (List.filter (\n -> Tuple.first n >= x) list) ) of
        Just val ->
            val

        Nothing ->
            (0,0)
-- case tail of value value of nothing (0,0)

pickTuples : List (Float, Float) -> Float -> ((Float, Float), (Float, Float))
pickTuples list x =
    case ((List.maximum (List.filter (\n -> Tuple.first n <= x) list))
    ,(List.minimum (List.filter (\n -> Tuple.first n >= x) list))
    ) of
        (Just val, Just val1) ->
            (val, val1)

        (Just val, Nothing) ->
            (val, val)

        (Nothing, Just val) ->
            (val, val)

        _ ->
            ((0,0), (0,0))

lookup : List (Float, Float) -> Float -> Float
lookup list x =
    let
        tuples =
            case ((List.maximum (List.filter (\n -> Tuple.first n <= x) list))
                 ,(List.minimum (List.filter (\n -> Tuple.first n >= x) list))
                 ) of

                (Just val, Just val1) ->
                    (val, val1)

                (Just val, Nothing) ->
                    (val, val)

                (Nothing, Just val) ->
                    (val, val)

                _ ->
                    ((0,0), (0,0))

        xone =
            Tuple.first (Tuple.first tuples)

        yone =
            Tuple.second (Tuple.first tuples)

        xtri =
            Tuple.first (Tuple.second tuples)

        ytri =
            Tuple.second (Tuple.second tuples)
    in
        interpolate xone yone xtri ytri x
#+END_SRC
* plots
** single line
** single area
** double line
** double area
* main
:PROPERTIES:
:header-args: :tangle src/Dev3.elm
:END:
** imports
#+BEGIN_SRC elm

module Dev3 exposing (..)


#+END_SRC
** main
#+BEGIN_SRC elm
-- MAIN
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }
#+END_SRC
** model
#+BEGIN_SRC elm
-- MODEL
#+END_SRC
** update
#+BEGIN_SRC elm
-- UPDATE
#+END_SRC
** view
#+BEGIN_SRC elm
-- VIEW
#+END_SRC
